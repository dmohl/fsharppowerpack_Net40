<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FsYacc</name></assembly>
<members>
<member name="P:FSharp.PowerPack.FsYacc.AST.PropagateTable.Item(System.Int64)">

</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.PropagateTable.Count">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.PropagateTable.Add(System.Int64,System.Int64)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.PropagateTable..ctor">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.PropagateTable">
<summary>
 A mutable table giving a Set&lt;KernelItemIndex&gt; for each kernel. The kernels represent the
 &quot;propagate&quot; items for the kernel. TODO: document this more w.r.t. the Dragon book.
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.SpontaneousTable.IEnumerable">

</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.SpontaneousTable.Count">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.SpontaneousTable.Add(System.Int64,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.SpontaneousTable..ctor">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.SpontaneousTable">
<summary>
 A mutable table giving a lookahead set Set&lt;Terminal&gt; for each kernel. The terminals represent the
 &quot;spontaneous&quot; items for the kernel. TODO: document this more w.r.t. the Dragon book.
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.Closure1Table.IEnumerable">

</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.Closure1Table.Count">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.Closure1Table.Contains(System.UInt32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.Closure1Table.Add(System.UInt32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.Closure1Table..ctor">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Closure1Table">
<summary>
 Hold the results of cpmuting the LALR(1) closure of an LR(0) kernel
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.KernelTable.Indexes">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.KernelTable.Kernel(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.KernelTable.Index(Microsoft.FSharp.Collections.FSharpSet{System.UInt32})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.KernelTable..ctor(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpSet{System.UInt32}})">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.KernelTable">
<summary>
 A mutable table giving an index to each LR(0) kernel. Kernels are referred to only by index.
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.LookaheadTable.Count">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.LookaheadTable.GetLookaheads(System.Int64)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.LookaheadTable.Contains(System.Int64,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.LookaheadTable.Add(System.Int64,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.LookaheadTable..ctor">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.LookaheadTable">
<summary>
 A mutable table maping kernels to sets of lookahead tokens
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.ProductionTable.Productions">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProductionTable.Symbols(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProductionTable.Symbol(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProductionTable.Precedence(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProductionTable.NonTerminal(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProductionTable..ctor(FSharp.PowerPack.FsYacc.AST.NonTerminalTable,FSharp.PowerPack.FsYacc.AST.TerminalTable,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{FSharp.PowerPack.FsYacc.AST.Production})">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.ProductionTable">
<summary>
 Allocate indexes for each production
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.TerminalTable.Indexes">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.TerminalTable.ToIndex(System.String)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.TerminalTable.PrecInfoOfIndex(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.TerminalTable.OfIndex(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.TerminalTable..ctor(Microsoft.FSharp.Collections.FSharpList{System.Tuple`2{System.String,FSharp.PowerPack.FsYacc.AST.PrecedenceInfo}})">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.TerminalTable">
<summary>
 Allocate indexes for each terminal
</summary>
</member>
<member name="P:FSharp.PowerPack.FsYacc.AST.NonTerminalTable.Indexes">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.NonTerminalTable.ToIndex(System.String)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.NonTerminalTable.OfIndex(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.NonTerminalTable..ctor(Microsoft.FSharp.Collections.FSharpList{System.String})">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.NonTerminalTable">
<summary>
 Allocate indexes for each non-terminal
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.GotoItemIndex">
<summary>
 Indexes into the memoizing table for the Goto computations
 Embed in a single integer, since these are faster
 keys for the dictionary hash tables

 Logically:

   type GotoItemIndex = GotoItemIdx of KernelIdx * SymbolIndex
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.KernelItemIndex">
<summary>
 Indexes in the LookaheadTable, SpontaneousTable, PropagateTable
 Embed in a single integer, since these are faster
 keys for the dictionary hash tables

 Logically:

   type KernelItemIndex = KernelItemIdx of KernelIdx * Item0
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.SymbolIndexes">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.SymbolIndex">
<summary>
 Representation of Symbols.
 Ideally would be declared as 
    type SymbolIndex = PTerminal of TerminalIndex | PNonTerminal of NonTerminalIndex
 but for performance reasons we embed as a simple integer (saves ~10%)

 We use an active pattern to reverse the embedding.
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.NonTerminalIndex">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.TerminalIndex">
<summary>
 Indexes in the TerminalTable and NonTerminalTable
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.KernelIdx">
<summary>
 Indexes of LR(0) kernels in the KernelTable
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Kernel">
<summary>
 LR(0) kernels
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Action">
<summary>
 Part of the output of CompilerLalrParserSpec
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Item0">
<summary>
 Represent (ProductionIndex,ProdictionDotIndex) as one integer 
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.ProdictionDotIndex">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.ProductionIndex">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.ProcessedParserSpec">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Production">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.PrecedenceInfo">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Symbols">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Symbol">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.NonTerminal">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Terminal">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Associativity">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Rule">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.ParserSpec">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Code">

</member>
<member name="T:FSharp.PowerPack.FsYacc.AST.Identifier">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.CompilerLalrParserSpec``1(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},FSharp.PowerPack.FsYacc.AST.ProcessedParserSpec)">
<summary>
 Compile a pre-processed LALR parser spec to tables following the Dragon book algorithm
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.CreateDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple`2{``0,``1}})">
<summary>
 A standard utility to create a dictionary from a list of pairs
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.Memoize``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 A general standard memoization utility. Be sure to apply to only one (function) argument to build the
 residue function!
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.LeastFixedPoint``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Collections.FSharpList{``0}},Microsoft.FSharp.Collections.FSharpSet{``0})">
<summary>
 A standard utility to compute a least fixed point of a set under a generative computation
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProcessWorkList``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.Unit}})">
<summary>
 Create a work list and loop until it is exhausted, calling a worker function for
 each element. Pass a function to queue additional work on the work list 
 to the worker function
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.|GotoItemIdx|(System.UInt64)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.GotoItemIdx(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.KernelItemIdx(System.Int32,System.UInt32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.|PTerminal|PNonTerminal|(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.PNonTerminal(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.PTerminal(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.outputPrecInfo(System.IO.TextWriter,FSharp.PowerPack.FsYacc.AST.PrecedenceInfo)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.dotIdx_of_item0(System.UInt32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.prodIdx_of_item0(System.UInt32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.mkItem0(System.Int32,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.ProcessParserSpecAst(FSharp.PowerPack.FsYacc.AST.ParserSpec)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.OutputAssoc(System.IO.TextWriter,FSharp.PowerPack.FsYacc.AST.Associativity)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.OutputTerminalSet(System.IO.TextWriter,System.Collections.Generic.IEnumerable{System.String})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.OutputSyms(System.IO.TextWriter,FSharp.PowerPack.FsYacc.AST.Symbol[]`1)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.OutputSym(System.IO.TextWriter,FSharp.PowerPack.FsYacc.AST.Symbol)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.StringOfSym(FSharp.PowerPack.FsYacc.AST.Symbol)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.AST.|KeyValue|``2(System.Collections.Generic.KeyValuePair{``0,``1})">
<summary>
 An active pattern that should be in the F# standard library
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.AST">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Driver.Lexbuf">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Driver.main">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Driver.actionCoding(FSharp.PowerPack.FsYacc.AST.Action)">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.anyMarker">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.actionMask">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.acceptFlag">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.errorFlag">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.reduceFlag">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.shiftFlag">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Driver.outputCodedUInt16``1(``0,System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Driver.output_int``1(``0,System.Int32)">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.usage">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.parslib">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.lexlib">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.inputCodePage">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.light">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.log">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.compat">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.tokenize">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.out">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.opens">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.internal_module">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.modname">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Driver.input">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Driver.UnicodeFileAsLexbuf(System.String,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Standard utility to create a Unicode LexBuffer

 One small annoyance is that LexBuffers and not IDisposable. This means 
 we can&apos;t just return the LexBuffer object, since the file it wraps wouldn&apos;t
 get closed when we&apos;re finished with the LexBuffer. Hence we return the stream,
 the reader and the LexBuffer. The caller should dispose the first two when done.
</summary>
</member>
<member name="T:FSharp.PowerPack.FsYacc.Driver">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_comment(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.comment(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_codestring(System.Text.StringBuilder,System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.codestring(System.Text.StringBuilder,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_code(Internal.Utilities.Text.Lexing.Position,System.Text.StringBuilder,System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.code(Internal.Utilities.Text.Lexing.Position,System.Text.StringBuilder,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_header(Internal.Utilities.Text.Lexing.Position,System.Text.StringBuilder,System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.header(Internal.Utilities.Text.Lexing.Position,System.Text.StringBuilder,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_token(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.token(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer._fslex_dummy``1">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Lexer._fslex_tables">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Lexer.actions">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Lexer.trans">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.gettype(System.String)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.unexpected_char``1(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.newline``1(Internal.Utilities.Text.Lexing.LexBuffer{``0})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Lexer.lexeme(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Lexer">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Parser.nonTerminalId">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Parser.tokenId">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Parser.token">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.spec``1(Microsoft.FSharp.Core.FSharpFunc`2{Internal.Utilities.Text.Lexing.LexBuffer{``0},FSharp.PowerPack.FsYacc.Parser.token},Internal.Utilities.Text.Lexing.LexBuffer{``0})">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.engine``1(Microsoft.FSharp.Core.FSharpFunc`2{Internal.Utilities.Text.Lexing.LexBuffer{``0},FSharp.PowerPack.FsYacc.Parser.token},Internal.Utilities.Text.Lexing.LexBuffer{``0},System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.tables">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser._fsyacc_reductions">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_immediateActions">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_productionToNonTerminalTable">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_reductionSymbolCounts">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_actionTableRowOffsets">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_actionTableElements">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_action_rows">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_stateToProdIdxsTableRowOffsets">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_stateToProdIdxsTableElements">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_sparseGotoTableRowOffsets">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_gotos">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser._fsyacc_dataOfToken(FSharp.PowerPack.FsYacc.Parser.token)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.token_to_string(FSharp.PowerPack.FsYacc.Parser.token)">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_tagOfErrorTerminal">

</member>
<member name="P:FSharp.PowerPack.FsYacc.Parser._fsyacc_endOfInputTag">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.tokenTagToTokenId(System.Int32)">

</member>
<member name="M:FSharp.PowerPack.FsYacc.Parser.tagOfToken(FSharp.PowerPack.FsYacc.Parser.token)">

</member>
<member name="T:FSharp.PowerPack.FsYacc.Parser">

</member>
<member name="P:Internal.Utilities.HashSet`1.Count">
<summary>
 The total number of elements in the set
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Remove(`0)">
<summary>
 Remove the given element from the set
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Iterate(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Fold``1(Microsoft.FSharp.Core.FSharpFunc`2{`0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},``0)">
<summary>
 Apply the given function to the set threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Copy">
<summary>
 Make a shallow copy of the set
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Contains(`0)">
<summary>
 Test if the set contains the given element
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Clear">
<summary>
 Clear all elements from the set
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1.Add(`0)">
<summary>
 Add an element to the collection
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1..ctor(System.Collections.Generic.IEnumerable{`0})">

</member>
<member name="M:Internal.Utilities.HashSet`1..ctor(System.Int32)">

</member>
<member name="M:Internal.Utilities.HashSet`1..ctor">

</member>
<member name="M:Internal.Utilities.HashSet`1..ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new mutable hash set with the given elements and using the given key hash/equality functions 
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1..ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable hash set with an internal bucket array of the given approximate size
 and with the given key hash/equality functions 
</summary>
</member>
<member name="M:Internal.Utilities.HashSet`1..ctor(System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable hash set using the given key hash/equality functions 
</summary>
</member>
<member name="T:Internal.Utilities.HashSet`1">
<summary>
 Mutable hash sets based by default on F# structural &quot;hash&quot; and (=) functions. Implemented via a hash table and/or Dictionary.
</summary>
</member>
<member name="T:Internal.Utilities.Arg.argspec">

</member>
<member name="T:Internal.Utilities.Arg.spec">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="M:Internal.Utilities.Arg.usage(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{System.String,Internal.Utilities.Arg.spec,System.String}},System.String)">
<summary>
 &quot;usage specs use&quot; prints the help for each argument.
</summary>
</member>
<member name="M:Internal.Utilities.Arg.parse_argv(Microsoft.FSharp.Core.FSharpRef{System.Int32},System.String[]`1,Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{System.String,Internal.Utilities.Arg.spec,System.String}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit},System.String)">

</member>
<member name="M:Internal.Utilities.Arg.parse(Microsoft.FSharp.Collections.FSharpList{System.Tuple`3{System.String,Internal.Utilities.Arg.spec,System.String}},Microsoft.FSharp.Core.FSharpFunc`2{System.String,Microsoft.FSharp.Core.Unit},System.String)">
<summary>
 &quot;parse specs f use&quot; parses the arguments given by Sys.argv
 according to the argument processing specifications &quot;specs&quot;.
 Arguments begin with &quot;-&quot;. Non-arguments are passed to &quot;f&quot; in
 order.  &quot;use&quot; is printed as part of the usage line if an error occurs.

 Permitted arguments are specified using triples: (arg, action, help).
 Actions are:
   Unit(f): call f, no subseq. arg
   Set(br): set ref to &apos;true&apos;, no subseq. arg.
   Clear(br): set ref to &apos;false, no subseq. arg.
   String(f): pass the subseq. arg to f
   Int(f): pass the subseq. arg to f
   Float(f): pass the subseq. arg to f
   Rest(f): pass all subseq. args to f in order
</summary>
</member>
<member name="T:Internal.Utilities.Arg.Help">

</member>
<member name="T:Internal.Utilities.Arg.Bad">

</member>
<member name="T:Internal.Utilities.Arg">
<summary>
 A simple command-line argument processor.
</summary>
</member>
<member name="T:Internal.Utilities.Compatibility.OCaml.Lexing.lexbuf">
<summary>
 ASCII LexBuffers 

 The type &quot;lexbuf&quot; is opaque, but has an internal position information field 
 that can be updated by setting &quot;lexbuf.EndPos&quot;, for example if you wish 
 to update the other fields in that position data before or during 
 lexing.  You will need to do this if you wish to maintain accurate 
 line-count information.  If you do this and wish to maintain strict 
 cross-compiling compatibility with OCamlLex and other tools you may need code 
 to conditionally use lexbuf_set_curr_p when compiling F# code.
</summary>
</member>
<member name="T:Internal.Utilities.Compatibility.OCaml.Lexing.position">

</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_end(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_start(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return absolute positions into the entire stream of characters
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexbuf_set_start_p(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte},Internal.Utilities.Text.Lexing.Position)">

</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexbuf_set_curr_p(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte},Internal.Utilities.Text.Lexing.Position)">

</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexbuf_curr_p(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 same as lexeme_end_p 
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_end_p(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_start_p(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the positions stored in the lexbuf for the matched string 
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_char(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte},System.Int32)">
<summary>
 Return a character from the matched string, innterpreting the bytes using an ASCII encoding
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_bytes(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the bytes for the matched string 
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme_utf8(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the matched string interpreting the bytes using the given Unicode text encoding
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.lexeme(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Return the matched string 
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_function(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte[]`1,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32}})">
<summary>
 Fuel a lexer from function that fills an array of bytes up to the given length, returning the
 number of bytes filled.
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_bytearray(System.Byte[]`1)">
<summary>
 Fuel a lexer from an array of bytes
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_string(System.String)">
<summary>
 Fuel a lexer from a string, converted to ascii using &lt;c&gt;System.Text.Encoding.ASCII.GetBytes&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_binary_reader(System.IO.BinaryReader)">
<summary>
 Fuel a lexer using the given BinaryReader.  
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_text_reader(System.Text.Encoding,System.IO.TextReader)">
<summary>
 Fuel a lexer using the given TextReader or StreamReader.
 The characters read are decoded to bytes using the given encoding (e.g. System.Text.Encoding.ASCII)
 and the bytes presented to the lexer.  The encoding used to decode the characters
 is associated with the expectations of the lexer (e.g. a lexer may be constructed to accept only 
 ASCII or pseudo-UTF8 bytes) and will typically be different to 
 the encoding used to decode the file.
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.from_channel(System.IO.TextReader)">
<summary>
 Fuel a lexer using the given in_channel.  The bytes are read using Pervasives.input.
 If the in_channel is a textual channel the bytes are 
 presented to the lexer by decoding the characters using System.Text.Encoding.ASCII.
</summary>
</member>
<member name="M:Internal.Utilities.Compatibility.OCaml.Lexing.flush_input(Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Remove all input, though don&apos;t discard the  except the current lexeme 
</summary>
</member>
<member name="T:Internal.Utilities.Compatibility.OCaml.Lexing">
<summary>
 Lexing: ML-like lexing support

 This file maintains rough compatibility for lexbuffers used by some ML
 laxer generators.  The lexbuf carries an associated pair of positions.
 Beware that only the &quot;cnum&quot; (absolute character number) field is automatically 
 updated as each lexeme is matched.  Upon each successful match the prior end
 position is transferred to be the start position and a new start position
 is allocated with an updated pos_cnum field.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex. 
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Create(System.UInt16[]`1[]`1,System.UInt16[]`1)">

</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.AsyncInterpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex, processing input asynchronously
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by fslex. 
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.AsciiTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Interpret tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.AsciiTables.Create(System.UInt16[]`1[]`1,System.UInt16[]`1)">

</member>
<member name="M:Internal.Utilities.Text.Lexing.AsciiTables.AsyncInterpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Byte})">
<summary>
 Interpret tables for an ascii lexer generated by fslex, processing input asynchronously
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.AsciiTables">
<summary>
 The type of tables for an ascii lexer generated by fslex. 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeLength">
<summary>
 The length of the matched string 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.Lexeme">
<summary>
 The matched string 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeString(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeChar(System.Int32)">
<summary>
 Fetch a particular character in the matched string 
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromTextReader(System.IO.TextReader)">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{`0[]`1,System.Int32,System.Int32},System.Int32})">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromChars(System.Char[]`1)">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromCharFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Char[]`1,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32}})">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromBytes(System.Byte[]`1)">
<summary>
 Adjust the start position associated with the lexbuf
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromByteFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Byte[]`1,Microsoft.FSharp.Core.FSharpFunc`2{System.Int32,System.Int32}})">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromBinaryReader(System.IO.BinaryReader)">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromAsyncFunction(Microsoft.FSharp.Core.FSharpFunc`2{System.Tuple`3{`0[]`1,System.Int32,System.Int32},Microsoft.FSharp.Control.FSharpAsync{System.Int32}})">

</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.DiscardInput">
<summary>
 Remove all input, though don&apos;t discard the current lexeme 
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.LexBuffer`1">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.NextLine">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated 
 using AsNewLinePos() and by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.FileName">
<summary>
 The file name associated with the input stream.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as filename, and  
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position, i.e. the difference between the AbsoluteOffset and the StartOfLineAbsoluteOffset
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Char">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.FirstLine(System.String)">
<summary>
 Get a position corresponding to the first line (line number 1) in a given file
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.AsNewLinePos">

</member>
<member name="T:Internal.Utilities.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.Tables`1.Interpret``1(Microsoft.FSharp.Core.FSharpFunc`2{Internal.Utilities.Text.Lexing.LexBuffer{``0},`0},Internal.Utilities.Text.Lexing.LexBuffer{``0},System.Int32)">

</member>
<member name="T:Internal.Utilities.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.StateStack">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ShiftTokens">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReducibleProductions">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReduceTokens">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ParseState">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.Message">

</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.CurrentToken">

</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseErrorContext`1">

</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultRange">

</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ParserLocalStore">

</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.RaiseError``1">

</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputStartPosition(System.Int32)">

</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputRange(System.Int32)">

</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputEndPosition(System.Int32)">

</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.GetInput(System.Int32)">

</member>
<member name="T:Internal.Utilities.Text.Parsing.IParseState">
<summary>
 Parsers generated by FsPars provide information from within parser
 actions.  This is accessed via the functions available on the local
 variable &lt;c&gt;parseState&lt;/c&gt; within parser actions
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.RecoverableParseError">

</member>
<member name="T:Internal.Utilities.Text.Parsing.Accept">

</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error(System.String)">

</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error_rich``1">

</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseHelpers">

</member>
</members>
</doc>
